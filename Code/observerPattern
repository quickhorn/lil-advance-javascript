/**
 * Observer pattern
 * - A one-to-many dependency between objects.
 * - When one object changes state, all its dependents are notified and updated automatically.
 * - Also known as Publish-Subscribe pattern
 
 */
class Product {
  constructor(name) {
    this.name = name;
    this.observers = [];
  }

  // The method that notifies all subscribers.
  backInStock() {
    // Define the product message.
    this.notifyObservers(`${this.name} is back in stock.`);
  }

  registerObserver(customer){
    this.observers.push(customer.boundMessage);
    console.log(`Added ${customer.name} as an observer`);
  }

  notifyObservers(productMessage){
    this.observers.forEach((customer) => customer(productMessage));
  }

  removeObserver(customer){
    console.log(customer);
    this.observers = this.observers.filter(
        //change from the LIL, they reused the customer variable
        //causing the observer to never be removed. And wasn't tested outside the console.log method
        
        (c) => c !== customer.boundMessage
    );
    console.log(this.observers);
    console.log(`Removed ${customer.name} as an observer`);
  }
}

class Customer {
  constructor(name) {
    this.name = name;
    this.boundMessage = this.message.bind(this);
  }

  // The method that is called when the customer is notified.
  message(productMessage) {
    console.log(`${this.name}, ${productMessage}`);
  }
}

// A product that is out of stock
let backpack = new Product("Green Frog Pack");

// Some customers
let simran = new Customer("Simran");
let maiken = new Customer("Maiken");

backpack.registerObserver(simran);
backpack.registerObserver(maiken);

// Notify all customers when backpack is back in stock
backpack.backInStock();

backpack.removeObserver(simran);

backpack.backInStock();